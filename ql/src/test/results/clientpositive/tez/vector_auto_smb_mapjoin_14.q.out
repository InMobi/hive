PREHOOK: query: -- SORT_QUERY_RESULTS

CREATE TABLE tbl1(key int, value string) CLUSTERED BY (key) SORTED BY (key) INTO 2 BUCKETS STORED AS ORC
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@tbl1
POSTHOOK: query: -- SORT_QUERY_RESULTS

CREATE TABLE tbl1(key int, value string) CLUSTERED BY (key) SORTED BY (key) INTO 2 BUCKETS STORED AS ORC
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@tbl1
PREHOOK: query: CREATE TABLE tbl2(key int, value string) CLUSTERED BY (key) SORTED BY (key) INTO 2 BUCKETS STORED AS ORC
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@tbl2
POSTHOOK: query: CREATE TABLE tbl2(key int, value string) CLUSTERED BY (key) SORTED BY (key) INTO 2 BUCKETS STORED AS ORC
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@tbl2
PREHOOK: query: insert overwrite table tbl1
select * from src where key < 10
PREHOOK: type: QUERY
PREHOOK: Input: default@src
PREHOOK: Output: default@tbl1
POSTHOOK: query: insert overwrite table tbl1
select * from src where key < 10
POSTHOOK: type: QUERY
POSTHOOK: Input: default@src
POSTHOOK: Output: default@tbl1
POSTHOOK: Lineage: tbl1.key EXPRESSION [(src)src.FieldSchema(name:key, type:string, comment:default), ]
POSTHOOK: Lineage: tbl1.value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
PREHOOK: query: insert overwrite table tbl2
select * from src where key < 10
PREHOOK: type: QUERY
PREHOOK: Input: default@src
PREHOOK: Output: default@tbl2
POSTHOOK: query: insert overwrite table tbl2
select * from src where key < 10
POSTHOOK: type: QUERY
POSTHOOK: Input: default@src
POSTHOOK: Output: default@tbl2
POSTHOOK: Lineage: tbl2.key EXPRESSION [(src)src.FieldSchema(name:key, type:string, comment:default), ]
POSTHOOK: Lineage: tbl2.value SIMPLE [(src)src.FieldSchema(name:value, type:string, comment:default), ]
PREHOOK: query: -- The join is being performed as part of sub-query. It should be converted to a sort-merge join
explain
select count(*) from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
PREHOOK: type: QUERY
POSTHOOK: query: -- The join is being performed as part of sub-query. It should be converted to a sort-merge join
explain
select count(*) from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_21] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_19] (rows=11 width=93)
                Conds:SEL_2._col0=SEL_5._col0(Inner)
              <-Select Operator [SEL_5] (rows=10 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_18] (rows=10 width=93)
                    predicate:key is not null
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=10 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_17] (rows=10 width=93)
                    predicate:key is not null
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
22
PREHOOK: query: -- The join is being performed as part of more than one sub-query. It should be converted to a sort-merge join
explain
select count(*) from
(
  select key, count(*) from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1
  group by key
) subq2
PREHOOK: type: QUERY
POSTHOOK: query: -- The join is being performed as part of more than one sub-query. It should be converted to a sort-merge join
explain
select count(*) from
(
  select key, count(*) from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1
  group by key
) subq2
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)
Reducer 3 <- Reducer 2 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3 vectorized
      File Output Operator [FS_19]
        Group By Operator [GBY_29] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Reducer 2 [SIMPLE_EDGE] vectorized
          SHUFFLE [RS_16]
            Group By Operator [GBY_28] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Select Operator [SEL_27] (rows=5 width=93)
                Group By Operator [GBY_26] (rows=5 width=93)
                  Output:["_col0"],keys:KEY._col0
                <-Map 1 [SIMPLE_EDGE]
                  SHUFFLE [RS_11]
                    PartitionCols:_col0
                    Group By Operator [GBY_10] (rows=11 width=93)
                      Output:["_col0"],keys:_col0
                      Merge Join Operator [MERGEJOIN_24] (rows=11 width=93)
                        Conds:SEL_2._col0=SEL_5._col0(Inner),Output:["_col0"]
                      <-Select Operator [SEL_5] (rows=10 width=93)
                          Output:["_col0"]
                          Filter Operator [FIL_23] (rows=10 width=93)
                            predicate:key is not null
                            TableScan [TS_3] (rows=10 width=93)
                              default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
                      <-Select Operator [SEL_2] (rows=10 width=93)
                          Output:["_col0"]
                          Filter Operator [FIL_22] (rows=10 width=93)
                            predicate:key is not null
                            TableScan [TS_0] (rows=10 width=93)
                              default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from
(
  select key, count(*) from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1
  group by key
) subq2
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from
(
  select key, count(*) from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1
  group by key
) subq2
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
6
PREHOOK: query: -- A join is being performed across different sub-queries, where a join is being performed in each of them.
-- Each sub-query should be converted to a sort-merge join.
explain
select src1.key, src1.cnt1, src2.cnt1 from
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1 group by key
) src1
join
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq2 group by key
) src2
on src1.key = src2.key
PREHOOK: type: QUERY
POSTHOOK: query: -- A join is being performed across different sub-queries, where a join is being performed in each of them.
-- Each sub-query should be converted to a sort-merge join.
explain
select src1.key, src1.cnt1, src2.cnt1 from
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1 group by key
) src1
join
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq2 group by key
) src2
on src1.key = src2.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)
Reducer 3 <- Reducer 2 (SIMPLE_EDGE), Reducer 6 (SIMPLE_EDGE)
Reducer 6 <- Map 5 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3
      File Output Operator [FS_32]
        Select Operator [SEL_31] (rows=5 width=102)
          Output:["_col0","_col1","_col2"]
          Merge Join Operator [MERGEJOIN_49] (rows=5 width=102)
            Conds:RS_51._col0=RS_53._col0(Inner),Output:["_col0","_col1","_col3"]
          <-Reducer 2 [SIMPLE_EDGE] vectorized
            SHUFFLE [RS_51]
              PartitionCols:_col0
              Group By Operator [GBY_50] (rows=5 width=93)
                Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
              <-Map 1 [SIMPLE_EDGE]
                SHUFFLE [RS_11]
                  PartitionCols:_col0
                  Group By Operator [GBY_10] (rows=11 width=93)
                    Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                    Merge Join Operator [MERGEJOIN_45] (rows=11 width=93)
                      Conds:SEL_2._col0=SEL_5._col0(Inner),Output:["_col0"]
                    <-Select Operator [SEL_5] (rows=10 width=93)
                        Output:["_col0"]
                        Filter Operator [FIL_42] (rows=10 width=93)
                          predicate:key is not null
                          TableScan [TS_3] (rows=10 width=93)
                            default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
                    <-Select Operator [SEL_2] (rows=10 width=93)
                        Output:["_col0"]
                        Filter Operator [FIL_41] (rows=10 width=93)
                          predicate:key is not null
                          TableScan [TS_0] (rows=10 width=93)
                            default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
          <-Reducer 6 [SIMPLE_EDGE] vectorized
            SHUFFLE [RS_53]
              PartitionCols:_col0
              Group By Operator [GBY_52] (rows=5 width=93)
                Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
              <-Map 5 [SIMPLE_EDGE]
                SHUFFLE [RS_25]
                  PartitionCols:_col0
                  Group By Operator [GBY_24] (rows=11 width=93)
                    Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                    Merge Join Operator [MERGEJOIN_47] (rows=11 width=93)
                      Conds:SEL_16._col0=SEL_19._col0(Inner),Output:["_col0"]
                    <-Select Operator [SEL_19] (rows=10 width=93)
                        Output:["_col0"]
                        Filter Operator [FIL_44] (rows=10 width=93)
                          predicate:key is not null
                          TableScan [TS_17] (rows=10 width=93)
                            default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
                    <-Select Operator [SEL_16] (rows=10 width=93)
                        Output:["_col0"]
                        Filter Operator [FIL_43] (rows=10 width=93)
                          predicate:key is not null
                          TableScan [TS_14] (rows=10 width=93)
                            default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select src1.key, src1.cnt1, src2.cnt1 from
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1 group by key
) src1
join
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq2 group by key
) src2
on src1.key = src2.key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select src1.key, src1.cnt1, src2.cnt1 from
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq1 group by key
) src1
join
(
  select key, count(*) as cnt1 from 
  (
    select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
  ) subq2 group by key
) src2
on src1.key = src2.key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
0	9	9
2	1	1
4	1	1
5	9	9
8	1	1
9	1	1
PREHOOK: query: -- The subquery itself is being joined. Since the sub-query only contains selects and filters, it should 
-- be converted to a sort-merge join.
explain
select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on subq1.key = subq2.key
PREHOOK: type: QUERY
POSTHOOK: query: -- The subquery itself is being joined. Since the sub-query only contains selects and filters, it should 
-- be converted to a sort-merge join.
explain
select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on subq1.key = subq2.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_21] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_19] (rows=3 width=102)
                Conds:SEL_2._col0=SEL_5._col0(Inner)
              <-Select Operator [SEL_5] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_18] (rows=3 width=93)
                    predicate:(key < 6)
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl2,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_17] (rows=3 width=93)
                    predicate:(key < 6)
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on subq1.key = subq2.key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on subq1.key = subq2.key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
20
PREHOOK: query: -- The subquery itself is being joined. Since the sub-query only contains selects and filters, it should 
-- be converted to a sort-merge join, although there is more than one level of sub-query
explain
select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join tbl2 b
  on subq2.key = b.key
PREHOOK: type: QUERY
POSTHOOK: query: -- The subquery itself is being joined. Since the sub-query only contains selects and filters, it should 
-- be converted to a sort-merge join, although there is more than one level of sub-query
explain
select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join tbl2 b
  on subq2.key = b.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_21] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_19] (rows=1 width=102)
                Conds:SEL_2._col0=SEL_5._col0(Inner)
              <-Select Operator [SEL_5] (rows=1 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_18] (rows=1 width=93)
                    predicate:((key < 8) and (key < 6))
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=1 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_17] (rows=1 width=93)
                    predicate:((key < 8) and (key < 6))
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join tbl2 b
  on subq2.key = b.key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join tbl2 b
  on subq2.key = b.key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
20
PREHOOK: query: -- Both the tables are nested sub-queries i.e more then 1 level of sub-query.
-- The join should be converted to a sort-merge join
explain
select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq3 
  where key < 6
  ) subq4
  on subq2.key = subq4.key
PREHOOK: type: QUERY
POSTHOOK: query: -- Both the tables are nested sub-queries i.e more then 1 level of sub-query.
-- The join should be converted to a sort-merge join
explain
select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq3 
  where key < 6
  ) subq4
  on subq2.key = subq4.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_21] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_19] (rows=1 width=102)
                Conds:SEL_2._col0=SEL_5._col0(Inner)
              <-Select Operator [SEL_5] (rows=1 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_18] (rows=1 width=93)
                    predicate:((key < 8) and (key < 6))
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=1 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_17] (rows=1 width=93)
                    predicate:((key < 8) and (key < 6))
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq3 
  where key < 6
  ) subq4
  on subq2.key = subq4.key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from 
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1 
  where key < 6
  ) subq2
  join
  (
  select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq3 
  where key < 6
  ) subq4
  on subq2.key = subq4.key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
#### A masked pattern was here ####
20
PREHOOK: query: -- The subquery itself is being joined. Since the sub-query only contains selects and filters and the join key
-- is not getting modified, it should be converted to a sort-merge join. Note that the sub-query modifies one 
-- item, but that is not part of the join key.
explain
select count(*) from 
  (select a.key as key, concat(a.value, a.value) as value from tbl1 a where key < 8) subq1 
    join
  (select a.key as key, concat(a.value, a.value) as value from tbl2 a where key < 8) subq2
  on subq1.key = subq2.key
PREHOOK: type: QUERY
POSTHOOK: query: -- The subquery itself is being joined. Since the sub-query only contains selects and filters and the join key
-- is not getting modified, it should be converted to a sort-merge join. Note that the sub-query modifies one 
-- item, but that is not part of the join key.
explain
select count(*) from 
  (select a.key as key, concat(a.value, a.value) as value from tbl1 a where key < 8) subq1 
    join
  (select a.key as key, concat(a.value, a.value) as value from tbl2 a where key < 8) subq2
  on subq1.key = subq2.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_21] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_19] (rows=3 width=102)
                Conds:SEL_2._col0=SEL_5._col0(Inner)
              <-Select Operator [SEL_5] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_18] (rows=3 width=93)
                    predicate:(key < 8)
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl2,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_17] (rows=3 width=93)
                    predicate:(key < 8)
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from 
  (select a.key as key, concat(a.value, a.value) as value from tbl1 a where key < 8) subq1 
    join
  (select a.key as key, concat(a.value, a.value) as value from tbl2 a where key < 8) subq2
  on subq1.key = subq2.key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from 
  (select a.key as key, concat(a.value, a.value) as value from tbl1 a where key < 8) subq1 
    join
  (select a.key as key, concat(a.value, a.value) as value from tbl2 a where key < 8) subq2
  on subq1.key = subq2.key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
20
PREHOOK: query: -- Since the join key is modified by the sub-query, neither sort-merge join not bucketized map-side
-- join should be performed
explain
select count(*) from 
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl1 a) subq1 
    join
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl2 a) subq2
  on subq1.key = subq2.key
PREHOOK: type: QUERY
POSTHOOK: query: -- Since the join key is modified by the sub-query, neither sort-merge join not bucketized map-side
-- join should be performed
explain
select count(*) from 
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl1 a) subq1 
    join
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl2 a) subq2
  on subq1.key = subq2.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE), Map 4 (SIMPLE_EDGE)
Reducer 3 <- Reducer 2 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 3 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_28] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Reducer 2 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_21] (rows=11 width=93)
                Conds:RS_24._col0=RS_27._col0(Inner)
              <-Map 1 [SIMPLE_EDGE] vectorized
                SHUFFLE [RS_24]
                  PartitionCols:_col0
                  Select Operator [SEL_23] (rows=10 width=93)
                    Output:["_col0"]
                    Filter Operator [FIL_22] (rows=10 width=93)
                      predicate:(key + 1) is not null
                      TableScan [TS_0] (rows=10 width=93)
                        default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Map 4 [SIMPLE_EDGE] vectorized
                SHUFFLE [RS_27]
                  PartitionCols:_col0
                  Select Operator [SEL_26] (rows=10 width=93)
                    Output:["_col0"]
                    Filter Operator [FIL_25] (rows=10 width=93)
                      predicate:(key + 1) is not null
                      TableScan [TS_3] (rows=10 width=93)
                        default@tbl2,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from 
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl1 a) subq1 
    join
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl2 a) subq2
  on subq1.key = subq2.key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from 
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl1 a) subq1 
    join
  (select a.key +1 as key, concat(a.value, a.value) as value from tbl2 a) subq2
  on subq1.key = subq2.key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
22
PREHOOK: query: -- One of the tables is a sub-query and the other is not.
-- It should be converted to a sort-merge join.
explain
select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join tbl2 a on subq1.key = a.key
PREHOOK: type: QUERY
POSTHOOK: query: -- One of the tables is a sub-query and the other is not.
-- It should be converted to a sort-merge join.
explain
select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join tbl2 a on subq1.key = a.key
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_21] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_19] (rows=3 width=102)
                Conds:SEL_2._col0=SEL_5._col0(Inner)
              <-Select Operator [SEL_5] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_18] (rows=3 width=93)
                    predicate:(key < 6)
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl2,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_17] (rows=3 width=93)
                    predicate:(key < 6)
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join tbl2 a on subq1.key = a.key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join tbl2 a on subq1.key = a.key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
20
PREHOOK: query: -- There are more than 2 inputs to the join, all of them being sub-queries. 
-- It should be converted to to a sort-merge join
explain
select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on (subq1.key = subq2.key)
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq3
  on (subq1.key = subq3.key)
PREHOOK: type: QUERY
POSTHOOK: query: -- There are more than 2 inputs to the join, all of them being sub-queries. 
-- It should be converted to to a sort-merge join
explain
select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on (subq1.key = subq2.key)
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq3
  on (subq1.key = subq3.key)
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_18]
        Group By Operator [GBY_31] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_15]
            Group By Operator [GBY_14] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_28] (rows=6 width=102)
                Conds:SEL_2._col0=SEL_5._col0(Inner),SEL_2._col0=SEL_8._col0(Inner)
              <-Select Operator [SEL_5] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_26] (rows=3 width=93)
                    predicate:(key < 6)
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl2,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_8] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_27] (rows=3 width=93)
                    predicate:(key < 6)
                    TableScan [TS_6] (rows=10 width=93)
                      default@tbl2,a,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=3 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_25] (rows=3 width=93)
                    predicate:(key < 6)
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on subq1.key = subq2.key
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq3
  on (subq1.key = subq3.key)
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from 
  (select a.key as key, a.value as value from tbl1 a where key < 6) subq1 
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq2
  on subq1.key = subq2.key
    join
  (select a.key as key, a.value as value from tbl2 a where key < 6) subq3
  on (subq1.key = subq3.key)
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
56
PREHOOK: query: -- The join is being performed on a nested sub-query, and an aggregation is performed after that.
-- The join should be converted to a sort-merge join
explain
select count(*) from (
  select subq2.key as key, subq2.value as value1, b.value as value2 from
  (
    select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1
    where key < 6
  ) subq2
join tbl2 b
on subq2.key = b.key) a
PREHOOK: type: QUERY
POSTHOOK: query: -- The join is being performed on a nested sub-query, and an aggregation is performed after that.
-- The join should be converted to a sort-merge join
explain
select count(*) from (
  select subq2.key as key, subq2.value as value1, b.value as value2 from
  (
    select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1
    where key < 6
  ) subq2
join tbl2 b
on subq2.key = b.key) a
POSTHOOK: type: QUERY
Plan optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-0
  Fetch Operator
    limit:-1
    Stage-1
      Reducer 2 vectorized
      File Output Operator [FS_14]
        Group By Operator [GBY_21] (rows=1 width=8)
          Output:["_col0"],aggregations:["count(VALUE._col0)"]
        <-Map 1 [SIMPLE_EDGE]
          SHUFFLE [RS_11]
            Group By Operator [GBY_10] (rows=1 width=8)
              Output:["_col0"],aggregations:["count()"]
              Merge Join Operator [MERGEJOIN_19] (rows=1 width=102)
                Conds:SEL_2._col0=SEL_5._col0(Inner)
              <-Select Operator [SEL_5] (rows=1 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_18] (rows=1 width=93)
                    predicate:((key < 8) and (key < 6))
                    TableScan [TS_3] (rows=10 width=93)
                      default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
              <-Select Operator [SEL_2] (rows=1 width=93)
                  Output:["_col0"]
                  Filter Operator [FIL_17] (rows=1 width=93)
                    predicate:((key < 8) and (key < 6))
                    TableScan [TS_0] (rows=10 width=93)
                      default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key"]

PREHOOK: query: select count(*) from (
  select subq2.key as key, subq2.value as value1, b.value as value2 from
  (
    select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1
    where key < 6
  ) subq2
join tbl2 b
on subq2.key = b.key) a
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
#### A masked pattern was here ####
POSTHOOK: query: select count(*) from (
  select subq2.key as key, subq2.value as value1, b.value as value2 from
  (
    select * from
    (
      select a.key as key, a.value as value from tbl1 a where key < 8
    ) subq1
    where key < 6
  ) subq2
join tbl2 b
on subq2.key = b.key) a
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
#### A masked pattern was here ####
20
PREHOOK: query: CREATE TABLE dest1(key int, value string)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@dest1
POSTHOOK: query: CREATE TABLE dest1(key int, value string)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@dest1
PREHOOK: query: CREATE TABLE dest2(key int, val1 string, val2 string)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@dest2
POSTHOOK: query: CREATE TABLE dest2(key int, val1 string, val2 string)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@dest2
PREHOOK: query: -- The join is followed by a multi-table insert. It should be converted to
-- a sort-merge join
explain
from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, val1, val2
PREHOOK: type: QUERY
POSTHOOK: query: -- The join is followed by a multi-table insert. It should be converted to
-- a sort-merge join
explain
from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, val1, val2
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Stage-4
  Stats-Aggr Operator
    Stage-0
      Move Operator
        table:{"name:":"default.dest1"}
        Stage-3
          Dependency Collection{}
            Stage-2
              Map 1
              File Output Operator [FS_9]
                table:{"name:":"default.dest1"}
                Select Operator [SEL_8] (rows=11 width=93)
                  Output:["_col0","_col1"]
                  Select Operator [SEL_7] (rows=11 width=93)
                    Output:["_col0","_col1","_col2"]
                    Merge Join Operator [MERGEJOIN_16] (rows=11 width=93)
                      Conds:FIL_14.key=FIL_15.key(Inner),Output:["_col0","_col1","_col6"]
                    <-Filter Operator [FIL_15] (rows=10 width=93)
                        predicate:key is not null
                        TableScan [TS_1] (rows=10 width=93)
                          default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
                    <-Filter Operator [FIL_14] (rows=10 width=93)
                        predicate:key is not null
                        TableScan [TS_0] (rows=10 width=93)
                          default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
              File Output Operator [FS_11]
                table:{"name:":"default.dest2"}
                 Please refer to the previous Select Operator [SEL_7]
Stage-5
  Stats-Aggr Operator
    Stage-1
      Move Operator
        table:{"name:":"default.dest2"}
         Please refer to the previous Stage-3

PREHOOK: query: from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, val1, val2
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
PREHOOK: Output: default@dest1
PREHOOK: Output: default@dest2
POSTHOOK: query: from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, val1, val2
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
POSTHOOK: Output: default@dest1
POSTHOOK: Output: default@dest2
POSTHOOK: Lineage: dest1.key SIMPLE [(tbl1)a.FieldSchema(name:key, type:int, comment:null), ]
POSTHOOK: Lineage: dest1.value SIMPLE [(tbl1)a.FieldSchema(name:value, type:string, comment:null), ]
POSTHOOK: Lineage: dest2.key SIMPLE [(tbl1)a.FieldSchema(name:key, type:int, comment:null), ]
POSTHOOK: Lineage: dest2.val1 SIMPLE [(tbl1)a.FieldSchema(name:value, type:string, comment:null), ]
POSTHOOK: Lineage: dest2.val2 SIMPLE [(tbl2)b.FieldSchema(name:value, type:string, comment:null), ]
PREHOOK: query: select * from dest1
PREHOOK: type: QUERY
PREHOOK: Input: default@dest1
#### A masked pattern was here ####
POSTHOOK: query: select * from dest1
POSTHOOK: type: QUERY
POSTHOOK: Input: default@dest1
#### A masked pattern was here ####
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
2	val_2
4	val_4
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
8	val_8
9	val_9
PREHOOK: query: select * from dest2
PREHOOK: type: QUERY
PREHOOK: Input: default@dest2
#### A masked pattern was here ####
POSTHOOK: query: select * from dest2
POSTHOOK: type: QUERY
POSTHOOK: Input: default@dest2
#### A masked pattern was here ####
0	val_0	val_0
0	val_0	val_0
0	val_0	val_0
0	val_0	val_0
0	val_0	val_0
0	val_0	val_0
0	val_0	val_0
0	val_0	val_0
0	val_0	val_0
2	val_2	val_2
4	val_4	val_4
5	val_5	val_5
5	val_5	val_5
5	val_5	val_5
5	val_5	val_5
5	val_5	val_5
5	val_5	val_5
5	val_5	val_5
5	val_5	val_5
5	val_5	val_5
8	val_8	val_8
9	val_9	val_9
PREHOOK: query: DROP TABLE dest2
PREHOOK: type: DROPTABLE
PREHOOK: Input: default@dest2
PREHOOK: Output: default@dest2
POSTHOOK: query: DROP TABLE dest2
POSTHOOK: type: DROPTABLE
POSTHOOK: Input: default@dest2
POSTHOOK: Output: default@dest2
PREHOOK: query: CREATE TABLE dest2(key int, cnt int)
PREHOOK: type: CREATETABLE
PREHOOK: Output: database:default
PREHOOK: Output: default@dest2
POSTHOOK: query: CREATE TABLE dest2(key int, cnt int)
POSTHOOK: type: CREATETABLE
POSTHOOK: Output: database:default
POSTHOOK: Output: default@dest2
PREHOOK: query: -- The join is followed by a multi-table insert, and one of the inserts involves a reducer.
-- It should be converted to a sort-merge join
explain
from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, count(*) group by key
PREHOOK: type: QUERY
POSTHOOK: query: -- The join is followed by a multi-table insert, and one of the inserts involves a reducer.
-- It should be converted to a sort-merge join
explain
from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, count(*) group by key
POSTHOOK: type: QUERY
Plan not optimized by CBO.

Vertex dependency in root stage
Reducer 2 <- Map 1 (SIMPLE_EDGE)

Stage-4
  Stats-Aggr Operator
    Stage-0
      Move Operator
        table:{"name:":"default.dest1"}
        Stage-3
          Dependency Collection{}
            Stage-2
              Reducer 2 vectorized
              File Output Operator [FS_25]
                table:{"name:":"default.dest2"}
                Select Operator [SEL_24] (rows=5 width=93)
                  Output:["_col0","_col1"]
                  Group By Operator [GBY_23] (rows=5 width=93)
                    Output:["_col0","_col1"],aggregations:["count(VALUE._col0)"],keys:KEY._col0
                  <-Map 1 [SIMPLE_EDGE]
                    File Output Operator [FS_9]
                      table:{"name:":"default.dest1"}
                      Merge Join Operator [MERGEJOIN_21] (rows=11 width=93)
                        Conds:FIL_19.key=FIL_20.key(Inner),Output:["_col0","_col1"]
                      <-Filter Operator [FIL_20] (rows=10 width=93)
                          predicate:key is not null
                          TableScan [TS_1] (rows=10 width=93)
                            default@tbl2,b,Tbl:COMPLETE,Col:NONE,Output:["key"]
                      <-Filter Operator [FIL_19] (rows=10 width=93)
                          predicate:key is not null
                          TableScan [TS_0] (rows=10 width=93)
                            default@tbl1,a,Tbl:COMPLETE,Col:NONE,Output:["key","value"]
                    SHUFFLE [RS_12]
                      PartitionCols:_col0
                      Group By Operator [GBY_11] (rows=11 width=93)
                        Output:["_col0","_col1"],aggregations:["count()"],keys:_col0
                        Select Operator [SEL_10] (rows=11 width=93)
                          Output:["_col0"]
                           Please refer to the previous Merge Join Operator [MERGEJOIN_21]
Stage-5
  Stats-Aggr Operator
    Stage-1
      Move Operator
        table:{"name:":"default.dest2"}
         Please refer to the previous Stage-3

PREHOOK: query: from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, count(*) group by key
PREHOOK: type: QUERY
PREHOOK: Input: default@tbl1
PREHOOK: Input: default@tbl2
PREHOOK: Output: default@dest1
PREHOOK: Output: default@dest2
POSTHOOK: query: from (
  select a.key as key, a.value as val1, b.value as val2 from tbl1 a join tbl2 b on a.key = b.key
) subq1
insert overwrite table dest1 select key, val1
insert overwrite table dest2 select key, count(*) group by key
POSTHOOK: type: QUERY
POSTHOOK: Input: default@tbl1
POSTHOOK: Input: default@tbl2
POSTHOOK: Output: default@dest1
POSTHOOK: Output: default@dest2
POSTHOOK: Lineage: dest1.key SIMPLE [(tbl1)a.FieldSchema(name:key, type:int, comment:null), ]
POSTHOOK: Lineage: dest1.value SIMPLE [(tbl1)a.FieldSchema(name:value, type:string, comment:null), ]
POSTHOOK: Lineage: dest2.cnt EXPRESSION [(tbl1)a.null, (tbl2)b.null, ]
POSTHOOK: Lineage: dest2.key SIMPLE [(tbl1)a.FieldSchema(name:key, type:int, comment:null), ]
PREHOOK: query: select * from dest1
PREHOOK: type: QUERY
PREHOOK: Input: default@dest1
#### A masked pattern was here ####
POSTHOOK: query: select * from dest1
POSTHOOK: type: QUERY
POSTHOOK: Input: default@dest1
#### A masked pattern was here ####
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
0	val_0
2	val_2
4	val_4
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
5	val_5
8	val_8
9	val_9
PREHOOK: query: select * from dest2
PREHOOK: type: QUERY
PREHOOK: Input: default@dest2
#### A masked pattern was here ####
POSTHOOK: query: select * from dest2
POSTHOOK: type: QUERY
POSTHOOK: Input: default@dest2
#### A masked pattern was here ####
0	9
2	1
4	1
5	9
8	1
9	1
